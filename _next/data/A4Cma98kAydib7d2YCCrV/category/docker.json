{"pageProps":{"slug":"docker","categories":["ReactJS","Docker","GI/CD","Tip","Gitlab","Microservice","K8s"],"allBlogs":[{"frontmatter":{"author":"Hieu Phan","date":"2020-06-22T15:22:00.000Z","image":"/images/6-quan-ly-log-tap-trung-elk-phan-1-tren-docker-swarm/cover.jpg","title":"Quản lý log tập trung trong microservice với ELK. Phần 1: trên docker swarm","readDuration":"30 min","categories":["Docker","Microservice"]},"markdownBody":"\n## 1. Kiến trúc\n\n![List node](/images/6-quan-ly-log-tap-trung-elk-phan-1-tren-docker-swarm/architect.png)\n\n## 2. Khởi tạo docker swarm\n\nBạn có thể dùng nhiều server có cài sẵn docker để tạo thành 1 cluster. Tốt nhất là docker cùng version để tránh gặp những lỗi tào lao. Trong bài viết này mình dùng docker-machine để giả lập 3 node để demo.\n\n### 2.1. Tạo 1 cluster với 3 node\n\n```bash\ndocker-machine create -d virtualbox --virtualbox-memory \"2048\" node1\ndocker-machine create -d virtualbox --virtualbox-memory \"1024\" node2\ndocker-machine create -d virtualbox --virtualbox-memory \"1024\" node3\n```\n\nFixing `out of memory` error of Elasticsearch\n\n```bash\ndocker-machine ssh node1 sudo sysctl -w vm.max_map_count=262144\ndocker-machine ssh node2 sudo sysctl -w vm.max_map_count=262144\ndocker-machine ssh node3 sudo sysctl -w vm.max_map_count=262144\n```\n\nKiểm tra các node đã tạo\n\n```bash\ndocker-machine ls\n```\n\n![List node](/images/6-quan-ly-log-tap-trung-elk-phan-1-tren-docker-swarm/1-list-node.png)\n\n### 2.2. Cho `node1` làm node manager.\n\n```bash\ndocker-machine ssh node1\ndocker swarm init --advertise-addr 192.168.99.104\n```\n\n`192.168.99.104` là ip của node 1, đã kiểm tra ở trên.\n\n![List node](/images/6-quan-ly-log-tap-trung-elk-phan-1-tren-docker-swarm/2-init-swarm.png)\n\nKết quả ở trên cho ta 1 command để các node khác có thể join vào cluster.\n\n### 2.3. Join các node còn lại vào cluster\n\nTa lần lượt ssh vào từng node và chạy lệnh join ở trên.\n\n```bash\ndocker-machine ssh node2\ndocker swarm join --token SWMTKN-1-5dk4ysohsctxbifjmb6x8xa5i6qps81au5k4fmzzqmne3l3oz0-ac99bh5vrw8zm3lychgpu3cwh 192.168.99.104:2377\n```\n\n```bash\ndocker-machine ssh node3\ndocker swarm join --token SWMTKN-1-5dk4ysohsctxbifjmb6x8xa5i6qps81au5k4fmzzqmne3l3oz0-ac99bh5vrw8zm3lychgpu3cwh 192.168.99.104:2377\n```\n\n> Chú ý: `token` trong lệnh `docker swarm join` sẽ khác nhau ở mỗi lần chạy. Nên chỗ này đừng copy của mình nhé. Lỗi đấy!\n\n## 3. Deploy ELK lên docker swarm\n\nSSH vào node manager `docker-machine ssh node1`.\n\nTạo 1 file `docker-stack.yml` có nội dung như sau:\n\n```yaml\nversion: '3'\n\nservices:\n  elasticsearch:\n    image: docker.elastic.co/elasticsearch/elasticsearch:7.8.0\n    ports:\n      - \"9200:9200\"\n    volumes:\n      - esdata:/usr/share/elasticsearch/data\n    environment:\n      ES_JAVA_OPTS: \"-Xmx256m -Xms256m\"\n      ELASTIC_PASSWORD: \"changeme\"\n      discovery.type: single-node\n    deploy:\n      placement:\n        constraints: [node.role == manager]\n\n  logstash:\n    image: docker.elastic.co/logstash/logstash:7.8.0\n    volumes:\n      - ./logstash.conf:/usr/share/logstash/pipeline/logstash.conf\n    depends_on:\n      - elasticsearch\n    deploy:\n      placement:\n        constraints: [node.role == manager]\n\n  kibana:\n    image: docker.elastic.co/kibana/kibana:7.8.0\n    environment:\n      ELASTICSEARCH_HOSTS: 'http://elasticsearch:9200'\n    ports:\n      - \"5601:5601\"\n    depends_on:\n      - logstash\n    deploy:\n      placement:\n        constraints: [node.role == manager]\n\n  logspout:\n    image: gliderlabs/logspout:v3\n    command: 'udp://logstash:5000'\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n    depends_on:\n      - logstash\n    deploy:\n      mode: global\n      restart_policy:\n        condition: on-failure\n        delay: 30s\n\n  visualizer:\n    image: dockersamples/visualizer:stable\n    ports:\n      - \"8081:8080\"\n    volumes:\n      - \"/var/run/docker.sock:/var/run/docker.sock\"\n    labels:\n      app: \"visualizer\"\n    deploy:\n      placement:\n        constraints: [node.role == manager]\n\nvolumes:\n  esdata:\n    driver: local\n```\n\nTạo 1 file `logstash.conf` có nội dung như sau:\n\n```\ninput {\n   udp {\n   \t\tport => 5000\n   \t\tcodec => json\n   \t}\n}\n\n## Add your filters / logstash plugins configuration here\n\nfilter {\n  if [docker][image] =~ /logstash/ {\n    drop { }\n  }\n}\n\noutput {\n    elasticsearch {\n      hosts => \"elasticsearch:9200\"\n      user => \"elastic\"\n      password => \"changeme\"\n    }\n\n    stdout { codec => rubydebug }\n}\n```\n\nTiến hành deploy\n\n```bash\ndocker stack deploy -c docker-stack.yml elk\n```\n\nThường mình sẽ gặp 1 lỗi là logspout sẽ không kết nối được đến logstash, do logstash chưa init xong. Bạn hãy đợi 1 thời gian rồi chạy `docker service update --force elk_logspout` để restart lại logspout trên các node.\n\n## 4. Xem log từ Kibana\n\nDùng browser truy cập vào 1 node bất kỳ trong swarm với port `5601`\n\n![List node](/images/6-quan-ly-log-tap-trung-elk-phan-1-tren-docker-swarm/1-list-node.png)\n\nTrong trường hợp của mình, mình sẽ truy cập vào `http://192.168.99.104:5601`.\n\n![Kibana](/images/6-quan-ly-log-tap-trung-elk-phan-1-tren-docker-swarm/3-kibana-1.jpg)\n\nTạo 1 index pattern `logstash*`\n![Kibana](/images/6-quan-ly-log-tap-trung-elk-phan-1-tren-docker-swarm/4-kibana-2.jpg)\n\n![Kibana](/images/6-quan-ly-log-tap-trung-elk-phan-1-tren-docker-swarm/5-kibana-3.jpg)\n\n![Kibana](/images/6-quan-ly-log-tap-trung-elk-phan-1-tren-docker-swarm/6-kibana-4.jpg)\n\n![Kibana](/images/6-quan-ly-log-tap-trung-elk-phan-1-tren-docker-swarm/7-kibana-5.jpg)\n\n![Kibana](/images/6-quan-ly-log-tap-trung-elk-phan-1-tren-docker-swarm/8-kibana-6.png)\n\nOke! Tới đây giao diện để truy xuất log đã hiện ra. Bạn có thể filter log theo thời gian, theo app,... Chỗ này bạn có thể tự mò nhé, giao diện kibana cũng khá dễ sử dụng.","slug":"6-quan-ly-log-tap-trung-elk-phan-1-tren-docker-swarm"},{"frontmatter":{"author":"Hieu Phan","date":"2020-06-20T09:26:00.000Z","image":"/images/5-docker-ngon-het-dung-luong-day-la-cach-don-dep/cover.jpg","title":"Docker ngốn hết dung lượng. Đây là cách dọn dẹp?","readDuration":"15 min","categories":["Docker"]},"markdownBody":"\n\n## 1. Container\n### 1.1. Stop and remove all containers\n\n```bash\ndocker stop $(docker ps -aq)\ndocker rm $(docker ps -aq)\n```\n\n### 1.2. Remove idle container\n\n```bash\ndocker rm $(docker ps -a -f status=exited -f status=created -q)\n```\n\n## 2. Volume\n### 2.1. Remove dangling volumes\nYêu cầu: Docker 1.9 and later\n\nDangling volumes là những volumes không liên kết với bất kỳ 1 container nào.\n\n```bash\ndocker volume prune\n```\n\n### 2.2. Remove container & it's volumes\n\n```bash\ndocker rm -v container_name\n```\n\n## 3. Image\n### 3.1. Remove unsed images\n\n```bash\ndocker rmi $(docker images -a -q)\n```\n\n### 3.2. Remove dangling images\n\nDangling images là những images có tag là `<none>`.\n\nKhi bạn dùng multistage để build 1 image thì sẽ xuất hiện những images kiểu thế này. Việc giữ lại những image này sẽ giúp bạn build nhanh hơn trong những lần tới, nhưng thường nó cũng ngốn dung lượng khá lớn. Hãy cân nhắc kỹ trước khi xóa nó.\n\n**List**\n```bash\ndocker images -f dangling=true\n```\n\n**Remove**\n```bash\ndocker images purge\n```\n\n## 4. Remove Unused/Dangling Images, Containers, Volumes, and Networks\n\nDocker cung cấp 1 command duy nhất để xóa những thứ không cần thiết. Bạn có thể thử. Nhưng nếu 1 ngày bạn chạy lệnh này rồi mà thấy đĩa cứng vẫn bị ngốn dung lượng một cách bí ẩn, hãy thử dùng các lệnh ở trên.\n\n```bash\ndocker system prune\n```\n\n**Include unused images (not just dangling images)**\n```bash\ndocker system prune -a\n```\n\n## 5. Giới hạn logs của docker\n\nKhi bạn chạy lệnh `docker logs container_name`, bạn sẽ xem được logs của container đó. Mỗi 1 container sẽ có logs riêng của nó. Mặc định, docker sẽ không giớ hạn số lượng/dung lượng logs của 1 container. Logs quá nhiều dấn đến disk của bạn cũng bị chiếm nhiều dung lượng\n\n> Log là 1 trong những tác nhân gây ngốn dung lượng **một cách thầm lặng** mà bạn sẽ khó mà nghĩ đến\n\nVì thế, ta cần giới hạn logs của mỗi container.\n\nTìm đến file `/etc/docker/daemon.json` (nếu không có thì tạo file mới). Thêm vào file đó với nội dung như sau:\n\n```json\n{\n  \"log-driver\": \"json-file\",\n  \"log-opts\": {\n    \"max-size\": \"10m\",\n    \"max-file\": \"3\"\n  }\n}\n```\n\n- **max-file:** số lượng file logs tối đa của 1 container\n- **max-size:** dung lượng tối đa của 1 file log mà 1 container sở hữu\n\nTừ config trên => 1 container có tối đa 3 file log, 1 file log có dung lượng tối đa 10MB. => Log tối đa 30MB.\n\nKhi log đã ghi hết file thứ 3, thì file thứ 1 (cũ nhất) sẽ bị xoá để ghi log mới.","slug":"5-docker-ngon-het-dung-luong-day-la-cach-don-dep"},{"frontmatter":{"author":"Hieu Phan","date":"2020-06-11T14:55:00.000Z","image":"/images/2-difference-copy-and-add-in-dockerfile/cover.jpg","title":"Dockerfile: COPY khác ADD?","readDuration":"10 min","categories":["Docker"]},"markdownBody":"\nNếu bạn thường build docker image hoặc đọc các tài liệu về docker, thỉnh thoảng bạn sẽ gặp `COPY` và `ADD`. Vậy `COPY` khác `ADD` có gì khác nhau? Nên sử dụng cái nào?\n\nCả `COPY` và `ADD` có một chức năng chung là chép file từ 1 nơi nào đó vào bên trong docker image. Còn điểm khác nhau?\n\n## COPY\n\n`COPY` cho phép bạn chép 1 file từ đĩa cứng vào docker image.\n\n## ADD\n\n`ADD`ngoài chức năng chép file từ đĩa cứng, còn hỗ trợ chép file từ 2 nguồn khác là:\n- Chép file từ 1 URL\n- Giải nén file tar vào docker image. Ví dụ `ADD http://abc.com/app.tar.xz /app/`, các file bên trong file `app.tar.xz` sẽ được chép vào `/app/` trong docker image.\n\n## Khi nào nên dùng `COPY`, khi nào nên dùng `ADD`?\nRiêng cá nhân mình, thì mình đa số dùng `COPY`, và rất ít dùng `ADD`. Vậy có phải mình đã bỏ qua 1 tính của docker là chép file từ url hay giải nén.\n\n> Docker image khi build sẽ tạo ra nhiều layer. Ứng với mỗi lệnh trong Dockerfile, sẽ có 1 layer được sinh ra. Khi dùng lệnh `ADD` để download file, và file đó sẽ được lưu mãi mãi tại layer của lệnh `ADD` đó. Trường hợp file cần download có dung lượng khoảng vài GB, nhưng chỉ dùng tạm để build app, và có thể xoá cũng không thể ảnh hưởng đến app, thì dùng `ADD` kích thước docker image sẽ rất lớn.\n\n**Tip:** Với việc download file mình sẽ `curl` thay thế cho `ADD`.\nVí dụ\n\n```Dockerfile\nRUN curl -O https://example.com/files/abc.tar.gz && \\\n    tar -xzf abc.tar.gz && \\\n    echo \"do something\" && \\\n    rm -rf abc && \\\n    rm abc.tar.gz\n```\n\nNhư vậy docker sẽ lưu lại 1 layer, layer này không có file `abc.tar.gz`","slug":"2-difference-copy-and-add-in-dockerfile"}],"title":"Hlog - Code for fun","description":"Cùng nhau chia sẻ kinh nghiệm, mò mẫm kiến thức mới","currentPage":1,"totalPage":1},"__N_SSG":true}