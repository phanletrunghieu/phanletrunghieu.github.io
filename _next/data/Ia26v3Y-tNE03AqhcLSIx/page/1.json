{"pageProps":{"categories":["ReactJS","Docker","GI/CD","Tip","Gitlab","Microservice","K8s"],"allBlogs":[{"frontmatter":{"author":"Hieu Phan","date":"2020-08-30T06:24:00.000Z","image":"/images/7-install-k3s-in-digitalocean/cover.jpg","title":"Setup K3s on Digitalocean","readDuration":"10 min","categories":["K8s"]},"markdownBody":"\n## 1. Create a Droplet\n\n![Create a Droplet](/images/7-install-k3s-in-digitalocean/1-create-a-droplet.png)\n\nResult:\n\n![Result Droplet](/images/7-install-k3s-in-digitalocean/2-result-droplet.jpg)\n\nTry to ssh to droplet.\n\n```bash\nssh root@123.456.789.012\n```\n\nInstall somethings:\n\n```bash\napt install curl\n```\n\nIf success, go to step 2.\n\n## 2. Install `k3sup` on your computer\n\n```bash\ncurl -sLS https://get.k3sup.dev | sh\n```\n\n## 3. Install k3s\n\n```bash\nk3sup install --ip 123.456.789.012 --user root\n```\n\n![Result 3-k3sup](/images/7-install-k3s-in-digitalocean/3-k3sup.png)\n\n## 4. Test\n\nAfter installing successfully, we have `kubeconfig` file.\n\n```bash\nexport KUBECONFIG=/Users/hieudeptrai/kubeconfig\nkubectl get node -o wide\n```\n\nDone!","slug":"7-install-k3s-in-digitalocean"},{"frontmatter":{"author":"Hieu Phan","date":"2020-06-22T15:22:00.000Z","image":"/images/6-quan-ly-log-tap-trung-elk-phan-1-tren-docker-swarm/cover.jpg","title":"Quản lý log tập trung trong microservice với ELK. Phần 1: trên docker swarm","readDuration":"30 min","categories":["Docker","Microservice"]},"markdownBody":"\n## 1. Kiến trúc\n\n![List node](/images/6-quan-ly-log-tap-trung-elk-phan-1-tren-docker-swarm/architect.png)\n\n## 2. Khởi tạo docker swarm\n\nBạn có thể dùng nhiều server có cài sẵn docker để tạo thành 1 cluster. Tốt nhất là docker cùng version để tránh gặp những lỗi tào lao. Trong bài viết này mình dùng docker-machine để giả lập 3 node để demo.\n\n### 2.1. Tạo 1 cluster với 3 node\n\n```bash\ndocker-machine create -d virtualbox --virtualbox-memory \"2048\" node1\ndocker-machine create -d virtualbox --virtualbox-memory \"1024\" node2\ndocker-machine create -d virtualbox --virtualbox-memory \"1024\" node3\n```\n\nFixing `out of memory` error of Elasticsearch\n\n```bash\ndocker-machine ssh node1 sudo sysctl -w vm.max_map_count=262144\ndocker-machine ssh node2 sudo sysctl -w vm.max_map_count=262144\ndocker-machine ssh node3 sudo sysctl -w vm.max_map_count=262144\n```\n\nKiểm tra các node đã tạo\n\n```bash\ndocker-machine ls\n```\n\n![List node](/images/6-quan-ly-log-tap-trung-elk-phan-1-tren-docker-swarm/1-list-node.png)\n\n### 2.2. Cho `node1` làm node manager.\n\n```bash\ndocker-machine ssh node1\ndocker swarm init --advertise-addr 192.168.99.104\n```\n\n`192.168.99.104` là ip của node 1, đã kiểm tra ở trên.\n\n![List node](/images/6-quan-ly-log-tap-trung-elk-phan-1-tren-docker-swarm/2-init-swarm.png)\n\nKết quả ở trên cho ta 1 command để các node khác có thể join vào cluster.\n\n### 2.3. Join các node còn lại vào cluster\n\nTa lần lượt ssh vào từng node và chạy lệnh join ở trên.\n\n```bash\ndocker-machine ssh node2\ndocker swarm join --token SWMTKN-1-5dk4ysohsctxbifjmb6x8xa5i6qps81au5k4fmzzqmne3l3oz0-ac99bh5vrw8zm3lychgpu3cwh 192.168.99.104:2377\n```\n\n```bash\ndocker-machine ssh node3\ndocker swarm join --token SWMTKN-1-5dk4ysohsctxbifjmb6x8xa5i6qps81au5k4fmzzqmne3l3oz0-ac99bh5vrw8zm3lychgpu3cwh 192.168.99.104:2377\n```\n\n> Chú ý: `token` trong lệnh `docker swarm join` sẽ khác nhau ở mỗi lần chạy. Nên chỗ này đừng copy của mình nhé. Lỗi đấy!\n\n## 3. Deploy ELK lên docker swarm\n\nSSH vào node manager `docker-machine ssh node1`.\n\nTạo 1 file `docker-stack.yml` có nội dung như sau:\n\n```yaml\nversion: '3'\n\nservices:\n  elasticsearch:\n    image: docker.elastic.co/elasticsearch/elasticsearch:7.8.0\n    ports:\n      - \"9200:9200\"\n    volumes:\n      - esdata:/usr/share/elasticsearch/data\n    environment:\n      ES_JAVA_OPTS: \"-Xmx256m -Xms256m\"\n      ELASTIC_PASSWORD: \"changeme\"\n      discovery.type: single-node\n    deploy:\n      placement:\n        constraints: [node.role == manager]\n\n  logstash:\n    image: docker.elastic.co/logstash/logstash:7.8.0\n    volumes:\n      - ./logstash.conf:/usr/share/logstash/pipeline/logstash.conf\n    depends_on:\n      - elasticsearch\n    deploy:\n      placement:\n        constraints: [node.role == manager]\n\n  kibana:\n    image: docker.elastic.co/kibana/kibana:7.8.0\n    environment:\n      ELASTICSEARCH_HOSTS: 'http://elasticsearch:9200'\n    ports:\n      - \"5601:5601\"\n    depends_on:\n      - logstash\n    deploy:\n      placement:\n        constraints: [node.role == manager]\n\n  logspout:\n    image: gliderlabs/logspout:v3\n    command: 'udp://logstash:5000'\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n    depends_on:\n      - logstash\n    deploy:\n      mode: global\n      restart_policy:\n        condition: on-failure\n        delay: 30s\n\n  visualizer:\n    image: dockersamples/visualizer:stable\n    ports:\n      - \"8081:8080\"\n    volumes:\n      - \"/var/run/docker.sock:/var/run/docker.sock\"\n    labels:\n      app: \"visualizer\"\n    deploy:\n      placement:\n        constraints: [node.role == manager]\n\nvolumes:\n  esdata:\n    driver: local\n```\n\nTạo 1 file `logstash.conf` có nội dung như sau:\n\n```\ninput {\n   udp {\n   \t\tport => 5000\n   \t\tcodec => json\n   \t}\n}\n\n## Add your filters / logstash plugins configuration here\n\nfilter {\n  if [docker][image] =~ /logstash/ {\n    drop { }\n  }\n}\n\noutput {\n    elasticsearch {\n      hosts => \"elasticsearch:9200\"\n      user => \"elastic\"\n      password => \"changeme\"\n    }\n\n    stdout { codec => rubydebug }\n}\n```\n\nTiến hành deploy\n\n```bash\ndocker stack deploy -c docker-stack.yml elk\n```\n\nThường mình sẽ gặp 1 lỗi là logspout sẽ không kết nối được đến logstash, do logstash chưa init xong. Bạn hãy đợi 1 thời gian rồi chạy `docker service update --force elk_logspout` để restart lại logspout trên các node.\n\n## 4. Xem log từ Kibana\n\nDùng browser truy cập vào 1 node bất kỳ trong swarm với port `5601`\n\n![List node](/images/6-quan-ly-log-tap-trung-elk-phan-1-tren-docker-swarm/1-list-node.png)\n\nTrong trường hợp của mình, mình sẽ truy cập vào `http://192.168.99.104:5601`.\n\n![Kibana](/images/6-quan-ly-log-tap-trung-elk-phan-1-tren-docker-swarm/3-kibana-1.jpg)\n\nTạo 1 index pattern `logstash*`\n![Kibana](/images/6-quan-ly-log-tap-trung-elk-phan-1-tren-docker-swarm/4-kibana-2.jpg)\n\n![Kibana](/images/6-quan-ly-log-tap-trung-elk-phan-1-tren-docker-swarm/5-kibana-3.jpg)\n\n![Kibana](/images/6-quan-ly-log-tap-trung-elk-phan-1-tren-docker-swarm/6-kibana-4.jpg)\n\n![Kibana](/images/6-quan-ly-log-tap-trung-elk-phan-1-tren-docker-swarm/7-kibana-5.jpg)\n\n![Kibana](/images/6-quan-ly-log-tap-trung-elk-phan-1-tren-docker-swarm/8-kibana-6.png)\n\nOke! Tới đây giao diện để truy xuất log đã hiện ra. Bạn có thể filter log theo thời gian, theo app,... Chỗ này bạn có thể tự mò nhé, giao diện kibana cũng khá dễ sử dụng.","slug":"6-quan-ly-log-tap-trung-elk-phan-1-tren-docker-swarm"},{"frontmatter":{"author":"Hieu Phan","date":"2020-06-20T09:26:00.000Z","image":"/images/5-docker-ngon-het-dung-luong-day-la-cach-don-dep/cover.jpg","title":"Docker ngốn hết dung lượng. Đây là cách dọn dẹp?","readDuration":"15 min","categories":["Docker"]},"markdownBody":"\n\n## 1. Container\n### 1.1. Stop and remove all containers\n\n```bash\ndocker stop $(docker ps -aq)\ndocker rm $(docker ps -aq)\n```\n\n### 1.2. Remove idle container\n\n```bash\ndocker rm $(docker ps -a -f status=exited -f status=created -q)\n```\n\n## 2. Volume\n### 2.1. Remove dangling volumes\nYêu cầu: Docker 1.9 and later\n\nDangling volumes là những volumes không liên kết với bất kỳ 1 container nào.\n\n```bash\ndocker volume prune\n```\n\n### 2.2. Remove container & it's volumes\n\n```bash\ndocker rm -v container_name\n```\n\n## 3. Image\n### 3.1. Remove unsed images\n\n```bash\ndocker rmi $(docker images -a -q)\n```\n\n### 3.2. Remove dangling images\n\nDangling images là những images có tag là `<none>`.\n\nKhi bạn dùng multistage để build 1 image thì sẽ xuất hiện những images kiểu thế này. Việc giữ lại những image này sẽ giúp bạn build nhanh hơn trong những lần tới, nhưng thường nó cũng ngốn dung lượng khá lớn. Hãy cân nhắc kỹ trước khi xóa nó.\n\n**List**\n```bash\ndocker images -f dangling=true\n```\n\n**Remove**\n```bash\ndocker images purge\n```\n\n## 4. Remove Unused/Dangling Images, Containers, Volumes, and Networks\n\nDocker cung cấp 1 command duy nhất để xóa những thứ không cần thiết. Bạn có thể thử. Nhưng nếu 1 ngày bạn chạy lệnh này rồi mà thấy đĩa cứng vẫn bị ngốn dung lượng một cách bí ẩn, hãy thử dùng các lệnh ở trên.\n\n```bash\ndocker system prune\n```\n\n**Include unused images (not just dangling images)**\n```bash\ndocker system prune -a\n```\n\n## 5. Giới hạn logs của docker\n\nKhi bạn chạy lệnh `docker logs container_name`, bạn sẽ xem được logs của container đó. Mỗi 1 container sẽ có logs riêng của nó. Mặc định, docker sẽ không giớ hạn số lượng/dung lượng logs của 1 container. Logs quá nhiều dấn đến disk của bạn cũng bị chiếm nhiều dung lượng\n\n> Log là 1 trong những tác nhân gây ngốn dung lượng **một cách thầm lặng** mà bạn sẽ khó mà nghĩ đến\n\nVì thế, ta cần giới hạn logs của mỗi container.\n\nTìm đến file `/etc/docker/daemon.json` (nếu không có thì tạo file mới). Thêm vào file đó với nội dung như sau:\n\n```json\n{\n  \"log-driver\": \"json-file\",\n  \"log-opts\": {\n    \"max-size\": \"10m\",\n    \"max-file\": \"3\"\n  }\n}\n```\n\n- **max-file:** số lượng file logs tối đa của 1 container\n- **max-size:** dung lượng tối đa của 1 file log mà 1 container sở hữu\n\nTừ config trên => 1 container có tối đa 3 file log, 1 file log có dung lượng tối đa 10MB. => Log tối đa 30MB.\n\nKhi log đã ghi hết file thứ 3, thì file thứ 1 (cũ nhất) sẽ bị xoá để ghi log mới.","slug":"5-docker-ngon-het-dung-luong-day-la-cach-don-dep"},{"frontmatter":{"author":"Hieu Phan","date":"2020-06-14T11:56:00.000Z","image":"/images/4-gitlab-cac-tinh-nang-hay-nhung-it-duoc-chu-y/cover.jpg","title":"Gitlab: Các tính năng hay nhưng ít được chú ý","readDuration":"15 min","categories":["Gitlab"]},"markdownBody":"\nCó thể nói Gitlab là 1 hệ sinh thái bao gồm các công cụ khá đầy đủ cho việc phát triển phần mềm, bao gồm: git registry, docker registry, CI/CD, task management,... Mĩnh sẽ giới thiệu thêm 1 vài tính năng nhỏ, nhưng rất hay\n\n## 1. Gitlab CI Template\n\n**Template trong cùng 1 file `.gitlab-ci.yml`**\n\n```yaml\nvariables:\n  GIT_CLEAN_FLAGS: none\n  IMAGE_NAME: registry.domain.com/app/payment_service\n  \n.build:\n  image: docker:stable\n  stage: build\n  services:\n    - docker:dind\n  script:\n    - mkdir -p ~/.docker\n    - echo $DOCKER_AUTH_CONFIG > ~/.docker/config.json\n    - docker build -t $IMAGE_NAME:$IMAGE_TAG .\n    - docker push $IMAGE_NAME:$IMAGE_TAG\n\nbuild-stagging:\n  extends: .build\n  variables:\n    IMAGE_TAG: latest-dev\n  only:\n    - master\n\nbuild-prod-version:\n  extends: .build\n  variables:\n    IMAGE_TAG: $CI_COMMIT_TAG\n  only:\n    - tag\n  except:\n    - branches\n\nbuild-prod-latest:\n  extends: .build\n  variables:\n    IMAGE_TAG: latest\n  only:\n    - tag\n  except:\n    - branches\n```\n\nTa sẽ định nghĩa những phần chung của tác vụ build vào `.build`. Trong `.build`, phần script mình có dùng 2 biến môi trường `IMAGE_NAME` và `IMAGE_TAG`. `IMAGE_NAME` thì mình có định nghĩa ở global `variables`. Còn `IMAGE_TAG` được định nghĩa ở đâu?\n\nSau đó ta sẽ định nghĩa những job build khác cho riêng từng môi trường, và extends lại `.build`. Ở đoạn trước mình còn câu hỏi `IMAGE_TAG` được định nghĩa ở đâu, thì ở từng môi trường mình sẽ build ra 1 docker image với 1 tag khác nhau. Vậy ở mỗi job extend từ `.build` ta sẽ thêm `IMAGE_TAG` vào `variables`, nó sẽ tự động gắn vào scripts trước đó để chạy.\n\n**Template từ 1 repo khác**\n\nVí dụ ta có 2 project được đặt ở 2 repo. 2 repo này ta có nhu cậu chạy những job giống nhau. Ta có thể tạo 1 repo `gitlab-ci-template` chứa 1 file `template.yml` có nội dung:\n\n```yaml\nvariables:\n  GO111MODULE: on\n  GIT_CLEAN_FLAGS: none\n\nstages:\n  - test\n\ntest:\n  stage: test\n  retry:\n    max: 1\n  only:\n    - master\n    - merge_requests\n  script:\n    - make lint\n    - make test\n```\n\n\nỞ 2 repo kia, ta tạo file `.gitlab-ci.yml` như sau:\n\n```yaml\ninclude:\n  - project: 'example-group/gitlab-ci-template'\n    ref: master\n    file: '/template.yml'\n\nimage: golang:1.14.4-alpine\n```\n\nVậy 2 repo đã có job `test`\n\n## 2. Coverage\n\n![Coverage example](/images/4-gitlab-cac-tinh-nang-hay-nhung-it-duoc-chu-y/coverage-example.png)\n\nVí dụ đối với 1 project sử dụng golang, khi test mình sẽ dùng lệnh\n\n```bash\ngo test -race -v -coverprofile=coverage/coverage.txt.tmp -count=1  ./...\n```\n\nTrong 1 đống kết quả trả về thì có 1 dòng hiển thị test đã coverage bao nhiêu phần trăm\n\n```\ntotal:\t\t\t\t\t(statements)\t93.6%\n```\n\nDùng regex để lấy đoạn này ra là `/total:\\s+\\(statements\\)\\s+(\\d+.\\d+\\%)/`\n\nCuối cùng là gắn regex trên vào `.gitlab-ci.yml` như sau:\n\n```yaml\nunit-test:\n  image: golang:1.14.4-alpine\n  stage: test\n  only:\n    - merge_requests\n  script:\n    - make unit-test\n  coverage: '/total:\\s+\\(statements\\)\\s+(\\d+.\\d+\\%)/'\n```\n\n## 3. Tự động retry job khi fail\n\n[Gitlab document](https://docs.gitlab.com/ee/ci/yaml/#retry)\n\n```yaml\nunit-test:\n  image: golang:1.14.4-alpine\n  stage: test\n  only:\n    - merge_requests\n  script:\n    - make unit-test\n  retry:\n    max: 2\n    when:\n      - runner_system_failure\n      - stuck_or_timeout_failure\n      - stuck_or_timeout_failure\n      - scheduler_failure\n      - api_failure\n```\n","slug":"4-gitlab-cac-tinh-nang-hay-nhung-it-duoc-chu-y"},{"frontmatter":{"author":"Hieu Phan","date":"2020-06-13T16:11:00.000Z","image":"/images/3-how-to-trigger-ci/cover.jpg","title":"Làm thế nào để trigger ci bằng commandline?","readDuration":"5 min","categories":["GI/CD","Tip"]},"markdownBody":"\nĐôi lúc bạn sẽ có nhu cần trigger CI cho 1 repo.\n\nLàm thế nào nhỉ?\n\n## Thử cách 1: Vào web ui để tạo 1 pipeline.\n\nVới cách này sẽ tốn khá nhiều thời gian, nào là truy cập web, nào là chuyển vào trang pipeline của repo,...\n\n=> Mất thời gian\n\n## Thử cách 2: Change code > commit -> push\n\nCòn với cách này sẽ nhanh hơn cách thứ 1, nhưng phải change code, và sẽ có 2 trường hợp:\n- 1 commit để change code, thêm 1 commit nữa để restore code về như cũ.\n- Tìm 1 chỗ nào đó không ảnh hưởng đến code khi chạy để thay đổi, ví dụ là comment.\n\n=> Hơi phức tạp\n\n## 1 solution có tiện hơn chăng?\n\nTheo nguyên lý hoạt động thì CI sẽ trigger khi có 1 commit mới.\n\n> Vậy ta chỉ cần commit mà không change code\n\n```bash\ngit commit --allow-empty -m \"Trigger ci\"\n```","slug":"3-how-to-trigger-ci"}],"title":"Hlog - Code for good, not for food","description":"Cùng nhau chia sẻ kinh nghiệm, mò mẫm kiến thức mới","currentPage":"1","totalPage":2},"__N_SSG":true}