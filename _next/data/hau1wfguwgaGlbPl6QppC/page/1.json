{"pageProps":{"categories":["ReactJS","Docker","GI/CD","Tip","Gitlab"],"allBlogs":[{"frontmatter":{"author":"Hieu Phan","date":"2020-06-20T09:26:00.000Z","image":"/images/5-docker-ngon-het-dung-luong-day-la-cach-don-dep/cover.jpg","title":"Docker ngốn hết dung lượng. Đây là cách dọn dẹp?","readDuration":"15 min","categories":["Docker"]},"markdownBody":"\n\n## 1. Container\n### 1.1. Stop and remove all containers\n\n```bash\ndocker stop $(docker ps -aq)\ndocker rm $(docker ps -aq)\n```\n\n### 1.2. Remove idle container\n\n```bash\ndocker rm $(docker ps -a -f status=exited -f status=created -q)\n```\n\n## 2. Volume\n### 2.1. Remove dangling volumes\nYêu cầu: Docker 1.9 and later\n\nDangling volumes là những volumes không liên kết với bất kỳ 1 container nào.\n\n```bash\ndocker volume prune\n```\n\n### 2.2. Remove container & it's volumes\n\n```bash\ndocker rm -v container_name\n```\n\n## 3. Image\n### 3.1. Remove unsed images\n\n```bash\ndocker rmi $(docker images -a -q)\n```\n\n### 3.2. Remove dangling images\n\nDangling images là những images có tag là `<none>`.\n\nKhi bạn dùng multistage để build 1 image thì sẽ xuất hiện những images kiểu thế này. Việc giữ lại những image này sẽ giúp bạn build nhanh hơn trong những lần tới, nhưng thường nó cũng ngốn dung lượng khá lớn. Hãy cân nhắc kỹ trước khi xóa nó.\n\n**List**\n```bash\ndocker images -f dangling=true\n```\n\n**Remove**\n```bash\ndocker images purge\n```\n\n## 4. Remove Unused/Dangling Images, Containers, Volumes, and Networks\n\nDocker cung cấp 1 command duy nhất để xóa những thứ không cần thiết. Bạn có thể thử. Nhưng nếu 1 ngày bạn chạy lệnh này rồi mà thấy đĩa cứng vẫn bị ngốn dung lượng một cách bí ẩn, hãy thử dùng các lệnh ở trên.\n\n```bash\ndocker system prune\n```\n\n**Include unused images (not just dangling images)**\n```bash\ndocker system prune -a\n```\n\n## 5. Giới hạn logs của docker\n\nKhi bạn chạy lệnh `docker logs container_name`, bạn sẽ xem được logs của container đó. Mỗi 1 container sẽ có logs riêng của nó. Mặc định, docker sẽ không giớ hạn số lượng/dung lượng logs của 1 container. Logs quá nhiều dấn đến disk của bạn cũng bị chiếm nhiều dung lượng\n\n> Log là 1 trong những tác nhân gây ngốn dung lượng **một cách thầm lặng** mà bạn sẽ khó mà nghĩ đến\n\nVì thế, ta cần giới hạn logs của mỗi container.\n\nTìm đến file `/etc/docker/daemon.json` (nếu không có thì tạo file mới). Thêm vào file đó với nội dung như sau:\n\n```json\n{\n  \"log-driver\": \"json-file\",\n  \"log-opts\": {\n    \"max-size\": \"10m\",\n    \"max-file\": \"3\"\n  }\n}\n```\n\n- **max-file:** số lượng file logs tối đa của 1 container\n- **max-size:** dung lượng tối đa của 1 file log mà 1 container sở hữu\n\nTừ config trên => 1 container có tối đa 3 file log, 1 file log có dung lượng tối đa 10MB. => Log tối đa 30MB.\n\nKhi log đã ghi hết file thứ 3, thì file thứ 1 (cũ nhất) sẽ bị xoá để ghi log mới.","slug":"5-docker-ngon-het-dung-luong-day-la-cach-don-dep"},{"frontmatter":{"author":"Hieu Phan","date":"2020-06-14T11:56:00.000Z","image":"/images/4-gitlab-cac-tinh-nang-hay-nhung-it-duoc-chu-y/cover.jpg","title":"Gitlab: Các tính năng hay nhưng ít được chú ý","readDuration":"15 min","categories":["Gitlab"]},"markdownBody":"\nCó thể nói Gitlab là 1 hệ sinh thái bao gồm các công cụ khá đầy đủ cho việc phát triển phần mềm, bao gồm: git registry, docker registry, CI/CD, task management,... Mĩnh sẽ giới thiệu thêm 1 vài tính năng nhỏ, nhưng rất hay\n\n## 1. Gitlab CI Template\n\n**Template trong cùng 1 file `.gitlab-ci.yml`**\n\n```yaml\nvariables:\n  GIT_CLEAN_FLAGS: none\n  IMAGE_NAME: registry.domain.com/app/payment_service\n  \n.build:\n  image: docker:stable\n  stage: build\n  services:\n    - docker:dind\n  script:\n    - mkdir -p ~/.docker\n    - echo $DOCKER_AUTH_CONFIG > ~/.docker/config.json\n    - docker build -t $IMAGE_NAME:$IMAGE_TAG .\n    - docker push $IMAGE_NAME:$IMAGE_TAG\n\nbuild-stagging:\n  extends: .build\n  variables:\n    IMAGE_TAG: latest-dev\n  only:\n    - master\n\nbuild-prod-version:\n  extends: .build\n  variables:\n    IMAGE_TAG: $CI_COMMIT_TAG\n  only:\n    - tag\n  except:\n    - branches\n\nbuild-prod-latest:\n  extends: .build\n  variables:\n    IMAGE_TAG: latest\n  only:\n    - tag\n  except:\n    - branches\n```\n\nTa sẽ định nghĩa những phần chung của tác vụ build vào `.build`. Trong `.build`, phần script mình có dùng 2 biến môi trường `IMAGE_NAME` và `IMAGE_TAG`. `IMAGE_NAME` thì mình có định nghĩa ở global `variables`. Còn `IMAGE_TAG` được định nghĩa ở đâu?\n\nSau đó ta sẽ định nghĩa những job build khác cho riêng từng môi trường, và extends lại `.build`. Ở đoạn trước mình còn câu hỏi `IMAGE_TAG` được định nghĩa ở đâu, thì ở từng môi trường mình sẽ build ra 1 docker image với 1 tag khác nhau. Vậy ở mỗi job extend từ `.build` ta sẽ thêm `IMAGE_TAG` vào `variables`, nó sẽ tự động gắn vào scripts trước đó để chạy.\n\n**Template từ 1 repo khác**\n\nVí dụ ta có 2 project được đặt ở 2 repo. 2 repo này ta có nhu cậu chạy những job giống nhau. Ta có thể tạo 1 repo `gitlab-ci-template` chứa 1 file `template.yml` có nội dung:\n\n```yaml\nvariables:\n  GO111MODULE: on\n  GIT_CLEAN_FLAGS: none\n\nstages:\n  - test\n\ntest:\n  stage: test\n  retry:\n    max: 1\n  only:\n    - master\n    - merge_requests\n  script:\n    - make lint\n    - make test\n```\n\n\nỞ 2 repo kia, ta tạo file `.gitlab-ci.yml` như sau:\n\n```yaml\ninclude:\n  - project: 'example-group/gitlab-ci-template'\n    ref: master\n    file: '/template.yml'\n\nimage: golang:1.14.4-alpine\n```\n\nVậy 2 repo đã có job `test`\n\n## 2. Coverage\n\n![Coverage example](/images/4-gitlab-cac-tinh-nang-hay-nhung-it-duoc-chu-y/coverage-example.png)\n\nVí dụ đối với 1 project sử dụng golang, khi test mình sẽ dùng lệnh\n\n```bash\ngo test -race -v -coverprofile=coverage/coverage.txt.tmp -count=1  ./...\n```\n\nTrong 1 đống kết quả trả về thì có 1 dòng hiển thị test đã coverage bao nhiêu phần trăm\n\n```\ntotal:\t\t\t\t\t(statements)\t93.6%\n```\n\nDùng regex để lấy đoạn này ra là `/total:\\s+\\(statements\\)\\s+(\\d+.\\d+\\%)/`\n\nCuối cùng là gắn regex trên vào `.gitlab-ci.yml` như sau:\n\n```yaml\nunit-test:\n  image: golang:1.14.4-alpine\n  stage: test\n  only:\n    - merge_requests\n  script:\n    - make unit-test\n  coverage: '/total:\\s+\\(statements\\)\\s+(\\d+.\\d+\\%)/'\n```\n\n## 3. Tự động retry job khi fail\n\n[Gitlab document](https://docs.gitlab.com/ee/ci/yaml/#retry)\n\n```yaml\nunit-test:\n  image: golang:1.14.4-alpine\n  stage: test\n  only:\n    - merge_requests\n  script:\n    - make unit-test\n  retry:\n    max: 2\n    when:\n      - runner_system_failure\n      - stuck_or_timeout_failure\n      - stuck_or_timeout_failure\n      - scheduler_failure\n      - api_failure\n```\n","slug":"4-gitlab-cac-tinh-nang-hay-nhung-it-duoc-chu-y"},{"frontmatter":{"author":"Hieu Phan","date":"2020-06-13T16:11:00.000Z","image":"/images/3-how-to-trigger-ci/cover.jpg","title":"Làm thế nào để trigger ci bằng commandline?","readDuration":"5 min","categories":["GI/CD","Tip"]},"markdownBody":"\nĐôi lúc bạn sẽ có nhu cần trigger CI cho 1 repo.\n\nLàm thế nào nhỉ?\n\n## Thử cách 1: Vào web ui để tạo 1 pipeline.\n\nVới cách này sẽ tốn khá nhiều thời gian, nào là truy cập web, nào là chuyển vào trang pipeline của repo,...\n\n=> Mất thời gian\n\n## Thử cách 2: Change code > commit -> push\n\nCòn với cách này sẽ nhanh hơn cách thứ 1, nhưng phải change code, và sẽ có 2 trường hợp:\n- 1 commit để change code, thêm 1 commit nữa để restore code về như cũ.\n- Tìm 1 chỗ nào đó không ảnh hưởng đến code khi chạy để thay đổi, ví dụ là comment.\n\n=> Hơi phức tạp\n\n## 1 solution có tiện hơn chăng?\n\nTheo nguyên lý hoạt động thì CI sẽ trigger khi có 1 commit mới.\n\n> Vậy ta chỉ cần commit mà không change code\n\n```bash\ngit commit --allow-empty -m \"Trigger ci\"\n```","slug":"3-how-to-trigger-ci"},{"frontmatter":{"author":"Hieu Phan","date":"2020-06-11T14:55:00.000Z","image":"/images/2-difference-copy-and-add-in-dockerfile/cover.jpg","title":"Dockerfile: COPY khác ADD?","readDuration":"10 min","categories":["Docker"]},"markdownBody":"\nNếu bạn thường build docker image hoặc đọc các tài liệu về docker, thỉnh thoảng bạn sẽ gặp `COPY` và `ADD`. Vậy `COPY` khác `ADD` có gì khác nhau? Nên sử dụng cái nào?\n\nCả `COPY` và `ADD` có một chức năng chung là chép file từ 1 nơi nào đó vào bên trong docker image. Còn điểm khác nhau?\n\n## COPY\n\n`COPY` cho phép bạn chép 1 file từ đĩa cứng vào docker image.\n\n## ADD\n\n`ADD`ngoài chức năng chép file từ đĩa cứng, còn hỗ trợ chép file từ 2 nguồn khác là:\n- Chép file từ 1 URL\n- Giải nén file tar vào docker image. Ví dụ `ADD http://abc.com/app.tar.xz /app/`, các file bên trong file `app.tar.xz` sẽ được chép vào `/app/` trong docker image.\n\n## Khi nào nên dùng `COPY`, khi nào nên dùng `ADD`?\nRiêng cá nhân mình, thì mình đa số dùng `COPY`, và rất ít dùng `ADD`. Vậy có phải mình đã bỏ qua 1 tính của docker là chép file từ url hay giải nén.\n\n> Docker image khi build sẽ tạo ra nhiều layer. Ứng với mỗi lệnh trong Dockerfile, sẽ có 1 layer được sinh ra. Khi dùng lệnh `ADD` để download file, và file đó sẽ được lưu mãi mãi tại layer của lệnh `ADD` đó. Trường hợp file cần download có dung lượng khoảng vài GB, nhưng chỉ dùng tạm để build app, và có thể xoá cũng không thể ảnh hưởng đến app, thì dùng `ADD` kích thước docker image sẽ rất lớn.\n\n**Tip:** Với việc download file mình sẽ `curl` thay thế cho `ADD`.\nVí dụ\n\n```Dockerfile\nRUN curl -O https://example.com/files/abc.tar.gz && \\\n    tar -xzf abc.tar.gz && \\\n    echo \"do something\" && \\\n    rm -rf abc && \\\n    rm abc.tar.gz\n```\n\nNhư vậy docker sẽ lưu lại 1 layer, layer này không có file `abc.tar.gz`","slug":"2-difference-copy-and-add-in-dockerfile"},{"frontmatter":{"author":"Hieu Phan","date":"2020-05-22T17:06:00.000Z","image":"/images/1-how-do-i-build-this-blog/cover.jpg","title":"Tôi đã tạo blog này thế nào?","readDuration":"45 min","categories":["ReactJS"]},"markdownBody":"\n## Chuẩn bị\n- Kiến thức cơ bản về ReactJS, NextJS\n- Soạn thảo văn bản với markdown\n- Tài khoản Github\n\n## Giới thiệu\nGithub có 1 chức năng là Github Page, cho phép chúng ta deploy những website tĩnh (HTML, css, javascript). Trước đây khi nhắc đến việc tạo ra 1 website tĩnh thì ta sẽ nghĩ ngay đến [GatsbyJS](https://www.gatsbyjs.org), còn NextJS là framework mạnh về việc hỗ trợ xây dựng ứng dụng React Server Side Render (SSR) và routing. Nhưng tin vui là vừa qua NextJS đã có thêm tính năng **Static Exporting**.\n\n> **Static Exporting** là gì vậy? Khác gì so với SSR?\n- SSR: server nhận được request -> server render code react thành html -> trả html về client\n- Static: html được tạo ra ngay khi ta build app -> server nhận được request -> trả html về client\n\n## Setup\n\n### Khởi tạo NextJS project\n\n```bash\nnpx create-next-app\n# or\nyarn create next-app\n```\n\nBlog này sẽ được deploy lên Github Page, và để tiện nhất, nhanh nhất, nên sẽ không có chuyện gọi API và lấy data để hiển thị. Dữ liệu blog sẽ được lưu trong những file markdown, mỗi file chứa một bài post.\n\nCấu trúc thư mục:\n- **assets:** các icon, hình ảnh để import trực tiếp vào React\n- **components:** các layout, component của blog (Header, Footer, Meta,...)\n- **data:** file `config.json` chứa các thông tin tổng quát của website (title, description, url,...)\n- **pages:** folder mặc định của NextJS. Mỗi file trong thư mục này tương ứng với 1 trang web.\n- **posts:** chứa các file markdown, nội dung của các bài post trong blog\n- **public:** chủ yếu chứa các hình ảnh chèn vào các bài post\n- **styles:** chứa các file scss, làm đẹp cho web\n\n### Config NextJS load file *.md\n\nCài `raw-loader` cho webpack\n```bash\nyarn add raw-loader\n```\n\nThêm nội dung sau vào file `next.config.js`. (Nếu không có thì tạo)\n\n```js\nmodule.exports = {\n    poweredByHeader: false,\n    webpack: function(config) {\n        config.module.rules.push({\n            test: /\\.md$/,\n            use: 'raw-loader',\n        })\n        return config\n    },\n}\n```\n\n### Config NextJS load icon svg\n\nCài `babel-plugin-inline-react-svg`\n```bash\nyarn add --dev babel-plugin-inline-react-svg\n```\n\nThêm nội dung sau vào file `.babelrc`. (Nếu không có thì tạo)\n\n```json\n{\n    \"presets\": [ \"next/babel\" ],\n    \"plugins\": [ \"inline-react-svg\" ]\n}\n```\n\n### Cài scss\n\nChỉ cần cài module `sass`\n\n```bash\nyarn add sass\n```\n\n## Code\n**Ý tưởng:** NextJS hỗ trợ build static thông qua 2 hàm `getStaticProps` và `getStaticPaths`. 2 hàm này được gọi khi build project. Mỗi file trong thư mục `pages` đều được NextJS hỗ trợ 2 hàm này. \n\n- getStaticProps: với hàm này, ta sẽ đọc dữ liệu từ file .md và truyền vào props của ReactComponent. Trong hàm này ta sẽ thực hiện:\n    - Đối với trang chủ hoặc trang category, ta sẽ đọc nội dung của tất cả file *.md. Truyền data vào props\n    - Đối với trang chi tiết, ta chỉ cần đọc đúng 1 file *md. Ví dụ `/post/abc-de` thì ta cần đọc file `abc-de.md`\n- getStaticPaths: url của 1 bài post là `/post/[slug]`. Ví dụ ta có 2 bài post là `post 1` và `post 2`, thì url là `/post/post-1` và `/post/post-2`. Như vậy trong hàm này, chúng ta sẽ thực hiện các tác vụ\n    - List hết tất cả file *.md trong folder `posts`\n    - Chuẩn hoá tên file thành url. `Post 1` thành `/post/post-1`\n\n## Deploy lên Github Page\n\nBình thường khi export project NextJS thành file html, ta sẽ dùng lệnh\n\n```bash\nnext export\n```\n\nNhưng Github Page sử dụng Jekyll, mà Jekyll thì không đọc được các file có ký tự \"_\" ở đầu (`_next`, `_app.js`). NextJS lại export ra rất nhiều file như thế. Nên ta cần disable Jekyll trong project.\n\nThay đổi các scripts trong file package.json như sau:\n```json\n\"scripts\": {\n    \"dev\": \"next dev\",\n    \"build\": \"next build && next export && touch out/.nojekyll\",\n    \"start\": \"next start\"\n}\n```\n\nChạy lệnh:\n```bash\nyarn build\n```\n\nNextJS sẽ export file là lưu vào folder `out`. Giờ ta chỉ cần push hết các file trong folder `out` lênn Github.\n\n![out folder](/images/1-how-do-i-build-this-blog/out-folder.png)\n\nURL Github Page sẽ có dạng https://{username}.github.io. Ví dụ: https://phanletrunghieu.github.io.\nVậy làm sao để code trong `out` có thể truy cập được thông qua tên miền trên.\nTạo 1 repo với lên là {username}.github.io (Ví dụ: phanletrunghieu.github.io). Và commit -> push code bên trong `out` lên.\n\nXong!\n\n## Kết\n\n[Project mẫu](https://github.com/phanletrunghieu/myblog)\n","slug":"1-how-do-i-build-this-blog"}],"title":"Hlog - Code for good, not for food","description":"Cùng nhau chia sẻ kinh nghiệm, mò mẫm kiến thức mới","currentPage":"1","totalPage":1},"__N_SSG":true}